* Você acredita que há um algoritmo para projetar “estações móveis de produção de sanduíche”? Quando o algoritmo é executado temos como resultado um “projeto” que atende os requisitos e detalha a estação móvel?

Não há um algoritmo geral para projetar 'estações móveis de produção de sanduíche', porém acredito existir um 'algoritmo' específico para cada caso de projeto que seja mais eficiente, porém é complexo definí-lo, antes da criação já ter sido efetuada.

* Você acredita que há um algoritmo para projetar software? Quando o algoritmo é executado temos como resultado um conjunto de módulos, ou no caso do algoritmo optar pelo projeto orientado a objetos teríamos um diagrama de classes, interfaces, a herança, a organização destes elementos em grupos (packages), a identificação de métodos e outros detalhes que, quando implementados e colocados em execução, atendem os requisitos estabelecidos?

Da mesma maneira, acredito existir um algoritmo para cada caso - porém é complexo definí-lo.

* Steve McConnell, no livro Code Complete, 2nd edition, Capítulo 5, afirma: “em projetos informais, muito do esforço de design é realizado enquanto programadores estão diante do teclado. O design é escrever em pseudocódigo a interface de uma classe, ou desenhar diagramas registrando o relacionamento entre algumas classes, ou perguntar a um outro programador qual padrão de projeto é uma melhor escolha.” Você concorda?

Concordo. Metodologias ágeis sendo pervasivas hoje tornaram decisões de design algo que ocorrem paralelamente com a construção do software.

* Steve McConnell, no livro Code Complete, 2nd edition, Capítulo 5, afirma: “técnicas de projeto tendem a ser “heurísticas”, “regras práticas” ou “coisas para tentar que algumas vezes funcionam” em vez de processos que podem ser repetidos e que produzem resultados previsíveis. Design envolve tentativa e erro. Uma técnica ou ferramenta que funciona bem em um cenário ou em algum aspecto de um cenário pode não funcionar no próximo projeto.” Você concorda?

Concordo, e diria que existe uma 'camada' acima disso, onde a própria tentativa e erro em si pode ser otimizada - por tentativa e erro.